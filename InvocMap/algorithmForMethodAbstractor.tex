\begin{minipage}[c]{0.45\textwidth}
\begin{lstlisting}[basicstyle=\tiny,caption={Algorithm for Method Invocation Abstraction},label={lt:AlgorithmMethodAbstractor}]
AST_Level3 abstractMethodInvocation(
		mi : MethodInvocation ,
		dictionaryAST : Set<AST_Level3>,
		visitor : InvocAbstractVisitor) {
	AST_Level3 result=new AST_Level3(mi);		
	visitor.result=result;
	
	//visit receiver if exist
	Expression receiverExpr=getReceiver(mi);		
	if(receiverExpr not null)
		visitor.visit(receiverExpr);
	
	// add method name and open parenthesis
	result.strCode.append(getMethodName(mi)+"(");
	
	// visit content of arguments
	Expression[] listArguments=getParams(mi);		
	for each Expression argExpr in listArguments:
		visitor.visit(argExpr);
	
	// add close parenthesis
	result.strCode.append(")");

	// set uniqueId
	setUniqueId(result,dictionaryAST);
	
	return result;		
}

\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[c]{0.45\textwidth}
\begin{lstlisting}[basicstyle=\tiny,caption={Definition of AST\_Level3 and InvocAbstractVisitor for collect information of MI},label={lt:AlgorithmMethodAbstractorPartB}]
class AST_Level3 {
	// field to store AST in level 3
	strCode : String;
	// Other informations
	listArguments : List<Type>;
	setImportedAPIs : Set<Type>;	
	strSignature : Type;
	// id is created by the uniqueness of 4 other fields 
	uniqueId : String;
	
}
class InvocAbstractVisitor extends ASTVisitor{
	result : AST_level3;
	...		
	void visit(ASTNode node) {
		// If visit local entity, abstract the place
		if(isLocalEntity(node)) {
			result.strCode.append("#");
			result.listArguments.append(getType(node));				
		} 
		else  {	
			// visit structure and update result
			visitStructure(node);
		} 			
		// Add type of node to set of imported APIs
		result.setImportedAPIs.add(getType(node));		
	}	
}
\end{lstlisting}

\end{minipage}\hfill


